-- Test two-column (int8, int8) indexes using radix sort build path
-- Triggers smol_sort_pairs_rows64() at line ~4184
SET client_min_messages = warning;
CREATE EXTENSION IF NOT EXISTS smol;
-- Create table with (int8, int8) columns
DROP TABLE IF EXISTS twocol_i8 CASCADE;
CREATE UNLOGGED TABLE twocol_i8(k1 int8, k2 int8, v int4);
-- Insert test data with various patterns
INSERT INTO twocol_i8
SELECT
    (i % 10000)::int8,                    -- k1: repeating values
    ((i * 7) % 5000)::int8,               -- k2: different pattern
    i::int4                                -- v: payload
FROM generate_series(1, 100000) i;
ANALYZE twocol_i8;
ALTER TABLE twocol_i8 SET (autovacuum_enabled = off);
-- Create SMOL index - will use radix sort for (int8, int8)
CREATE INDEX twocol_i8_smol ON twocol_i8 USING smol(k1, k2);
ANALYZE twocol_i8;
-- Compare with btree baseline
CREATE INDEX twocol_i8_btree ON twocol_i8 USING btree(k1, k2);
SET enable_seqscan = off;
SET enable_bitmapscan = off;
SET enable_indexonlyscan = off;
SET enable_indexscan = on;
-- Collect btree results
SELECT count(*) AS cnt1, sum(v)::bigint AS sum1 FROM twocol_i8 WHERE k1 >= 5000 AND k2 >= 2500 \gset bt_
ERROR:  smol supports index-only scans only
-- Drop btree, test SMOL
DROP INDEX twocol_i8_btree;
-- Verify SMOL matches btree
SELECT
    (SELECT count(*) FROM twocol_i8 WHERE k1 >= 5000 AND k2 >= 2500) = :'bt_cnt1' AS cnt_match,
    (SELECT sum(v)::bigint FROM twocol_i8 WHERE k1 >= 5000 AND k2 >= 2500) = :'bt_sum1' AS sum_match;
ERROR:  syntax error at or near ":"
LINE 2: ...FROM twocol_i8 WHERE k1 >= 5000 AND k2 >= 2500) = :'bt_cnt1'...
                                                             ^
-- Test with different ranges
SELECT count(*), sum(v)::bigint FROM twocol_i8 WHERE k1 = 1000 AND k2 >= 1000;
ERROR:  smol supports index-only scans only
SELECT count(*), sum(v)::bigint FROM twocol_i8 WHERE k1 >= 9000 AND k2 < 1000;
ERROR:  smol supports index-only scans only
SELECT count(*), min(k1), max(k1), min(k2), max(k2) FROM twocol_i8 WHERE k1 >= 5000;
ERROR:  smol supports index-only scans only
-- Test edge cases with negative values
DROP TABLE IF EXISTS twocol_i8_neg CASCADE;
CREATE UNLOGGED TABLE twocol_i8_neg(k1 int8, k2 int8);
INSERT INTO twocol_i8_neg VALUES
    (-9223372036854775808, -9223372036854775808),  -- MIN int64
    (-1000, -500),
    (0, 0),
    (1000, 500),
    (9223372036854775807, 9223372036854775807);    -- MAX int64
CREATE INDEX twocol_i8_neg_smol ON twocol_i8_neg USING smol(k1, k2);
SELECT k1, k2 FROM twocol_i8_neg WHERE k1 >= -1000 ORDER BY k1, k2;
ERROR:  smol supports index-only scans only
SELECT count(*) FROM twocol_i8_neg WHERE k1 < 0;
ERROR:  smol supports index-only scans only
-- Test with large dataset to ensure radix sort handles volume
DROP TABLE IF EXISTS twocol_i8_large CASCADE;
CREATE UNLOGGED TABLE twocol_i8_large(k1 int8, k2 int8);
INSERT INTO twocol_i8_large
SELECT (i % 1000000)::int8, (i % 500000)::int8
FROM generate_series(1, 500000) i;
CREATE INDEX twocol_i8_large_smol ON twocol_i8_large USING smol(k1, k2);
ANALYZE twocol_i8_large;
SELECT count(*) FROM twocol_i8_large WHERE k1 >= 500000;
ERROR:  smol supports index-only scans only
SELECT count(*) FROM twocol_i8_large WHERE k1 >= 0 AND k2 >= 250000;
ERROR:  smol supports index-only scans only
-- Cleanup
DROP TABLE twocol_i8 CASCADE;
DROP TABLE twocol_i8_neg CASCADE;
DROP TABLE twocol_i8_large CASCADE;
