-- Test to achieve 100% code coverage
-- Covers: cost GUCs, error paths, multi-level B-tree
SET client_min_messages = warning;
CREATE EXTENSION IF NOT EXISTS smol;
SET enable_seqscan = off;
SET enable_bitmapscan = off;
-- Test 1: Cost GUC customization (lines 3582-3584, 3591-3593)
DROP TABLE IF EXISTS t_cost CASCADE;
CREATE UNLOGGED TABLE t_cost (k int4);
INSERT INTO t_cost SELECT i FROM generate_series(1, 1000) i;
CREATE INDEX t_cost_idx ON t_cost USING smol(k);
-- Trigger cost calculation with smol.cost_page != 1.0
SET smol.cost_page = 1.5;
EXPLAIN SELECT * FROM t_cost WHERE k > 500;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Index Only Scan using t_cost_idx on t_cost  (cost=0.00..14.08 rows=333 width=4)
   Index Cond: (k > 500)
(2 rows)

-- Trigger cost calculation with smol.cost_tup != 1.0
SET smol.cost_page = 1.0;
SET smol.cost_tup = 0.8;
EXPLAIN SELECT * FROM t_cost WHERE k > 500;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Index Only Scan using t_cost_idx on t_cost  (cost=0.00..12.83 rows=333 width=4)
   Index Cond: (k > 500)
(2 rows)

-- Reset
SET smol.cost_page = 1.0;
SET smol.cost_tup = 1.0;
-- Test 2: Multi-level B-tree internal nodes (lines 4811-4831)
-- Need enough data to create multiple leaf pages and trigger internal node creation
-- SMOL compresses data very efficiently, need many rows to force multiple leaf pages
-- Disable parallel workers to ensure non-parallel build path
SET max_parallel_maintenance_workers = 0;
DROP TABLE IF EXISTS t_large CASCADE;
CREATE UNLOGGED TABLE t_large (k int4);
-- Insert enough rows to force multiple leaf pages and internal levels
-- Need at least 2 leaf pages to trigger internal level building
INSERT INTO t_large SELECT i FROM generate_series(1, 100000) i;
CREATE INDEX t_large_idx ON t_large USING smol(k);
-- Verify multi-level structure was created (multiple leaf pages)
SELECT total_pages, leaf_pages FROM smol_inspect('t_large_idx');
 total_pages | leaf_pages 
-------------+------------
          53 |         50
(1 row)

-- Query to use the multi-level index
SELECT count(*) FROM t_large WHERE k > 1000;
 count 
-------
 99000
(1 row)

-- Test 3: INCLUDE columns with various sizes - backward scan (lines 2701-2703)
-- Covers INCLUDE column copy for sizes 2, 8, 16 bytes in backward scans
DROP TABLE IF EXISTS t_inc_sizes CASCADE;
CREATE UNLOGGED TABLE t_inc_sizes (k int4, v_int2 int2, v_int8 int8, v_uuid uuid);
INSERT INTO t_inc_sizes SELECT i, (i*2)::int2, (i*100)::int8, gen_random_uuid() FROM generate_series(1, 100) i;
CREATE INDEX t_inc_sizes_idx ON t_inc_sizes USING smol(k) INCLUDE (v_int2, v_int8, v_uuid);
-- Backward scan to trigger lines 2701-2703
SELECT k, v_int2, v_int8 FROM t_inc_sizes WHERE k > 90 ORDER BY k DESC LIMIT 5;
  k  | v_int2 | v_int8 
-----+--------+--------
 100 |    200 |  10000
  99 |    198 |   9900
  98 |    196 |   9800
  97 |    194 |   9700
  96 |    192 |   9600
(5 rows)

-- Test 4: Two-column indexes with non-byval keys (lines 6155, 6170)
-- Covers memcpy for non-byval types (text, uuid)
DROP TABLE IF EXISTS t_twocol_text CASCADE;
CREATE UNLOGGED TABLE t_twocol_text (a text, b text, c int4);
INSERT INTO t_twocol_text SELECT 'key' || i, 'val' || i, i FROM generate_series(1, 100) i;
CREATE INDEX t_twocol_text_idx ON t_twocol_text USING smol(a, b) INCLUDE (c);
ERROR:  smol supports fixed-length key types only (attno=2)
SELECT count(*) FROM t_twocol_text WHERE a > 'key50';
 count 
-------
    53
(1 row)

DROP TABLE IF EXISTS t_twocol_uuid CASCADE;
CREATE UNLOGGED TABLE t_twocol_uuid (a uuid, b uuid, c int4);
INSERT INTO t_twocol_uuid SELECT gen_random_uuid(), gen_random_uuid(), i FROM generate_series(1, 100) i;
CREATE INDEX t_twocol_uuid_idx ON t_twocol_uuid USING smol(a, b) INCLUDE (c);
SELECT count(*) FROM t_twocol_uuid;
 count 
-------
   100
(1 row)

-- Test 5: Two-column indexes with various key sizes and INCLUDE (byval cases)
DROP TABLE IF EXISTS t_twocol_int2 CASCADE;
CREATE UNLOGGED TABLE t_twocol_int2 (a int2, b int2, c int4);
INSERT INTO t_twocol_int2 SELECT i::int2, (i*2)::int2, i*10 FROM generate_series(1, 100) i;
CREATE INDEX t_twocol_int2_idx ON t_twocol_int2 USING smol(a, b) INCLUDE (c);
SELECT count(*) FROM t_twocol_int2 WHERE a > 50;
 count 
-------
    29
(1 row)

DROP TABLE IF EXISTS t_twocol_int8 CASCADE;
CREATE UNLOGGED TABLE t_twocol_int8 (a int8, b int8, c int4);
INSERT INTO t_twocol_int8 SELECT i::int8, (i*2)::int8, i*10 FROM generate_series(1, 100) i;
CREATE INDEX t_twocol_int8_idx ON t_twocol_int8 USING smol(a, b) INCLUDE (c);
SELECT count(*) FROM t_twocol_int8 WHERE a > 50;
 count 
-------
    76
(1 row)

DROP TABLE IF EXISTS t_twocol_char CASCADE;
CREATE UNLOGGED TABLE t_twocol_char (a "char", b "char", c int4);
INSERT INTO t_twocol_char SELECT i::"char", (i+10)::"char", i*10 FROM generate_series(1, 50) i;
CREATE INDEX t_twocol_char_idx ON t_twocol_char USING smol(a, b) INCLUDE (c);
SELECT count(*) FROM t_twocol_char WHERE a > 25::"char";
 count 
-------
     5
(1 row)

-- Test 6: smol_inspect with empty index (lines 6423-6424)
-- Covers zero compression stats when height <= 1
DROP TABLE IF EXISTS t_empty_inspect CASCADE;
CREATE UNLOGGED TABLE t_empty_inspect (k int4);
CREATE INDEX t_empty_inspect_idx ON t_empty_inspect USING smol(k);
-- Empty index should have height=0, triggering lines 6423-6424
SELECT total_pages, zerocopy_pct, compression_pct FROM smol_inspect('t_empty_inspect_idx');
 total_pages | zerocopy_pct | compression_pct 
-------------+--------------+-----------------
           2 |            0 |               0
(1 row)

-- Test 7: Parallel build with max_parallel_maintenance_workers=0 (line 6578)
-- Setting to 0 should trigger early return
SET max_parallel_maintenance_workers = 0;
DROP TABLE IF EXISTS t_no_parallel CASCADE;
CREATE UNLOGGED TABLE t_no_parallel (k int4);
INSERT INTO t_no_parallel SELECT i FROM generate_series(1, 10000) i;
CREATE INDEX t_no_parallel_idx ON t_no_parallel USING smol(k);
SELECT count(*) FROM t_no_parallel WHERE k > 5000;
 count 
-------
  5000
(1 row)

-- Reset parallel workers
SET max_parallel_maintenance_workers = DEFAULT;
-- Test 8: Force tall trees with smol.test_max_tuples_per_page GUC
-- Covers smol_rightmost_in_subtree loop (lines 5379-5387) with smaller dataset
-- Setting GUC caps tuples per page, forcing more pages and taller tree
SET smol.test_max_tuples_per_page = 100;
DROP TABLE IF EXISTS t_tall_guc CASCADE;
CREATE UNLOGGED TABLE t_tall_guc (k int4, i1 int4, i2 int4, i3 int4, i4 int4, i5 int4, i6 int4, i7 int4, i8 int4);
INSERT INTO t_tall_guc SELECT i, i, i, i, i, i, i, i, i FROM generate_series(1, 50000) i;
CREATE INDEX t_tall_guc_idx ON t_tall_guc USING smol(k) INCLUDE (i1, i2, i3, i4, i5, i6, i7, i8);
-- Verify many more pages than normal (should have 400+ leaf pages)
SELECT total_pages > 400 AS has_many_pages, leaf_pages > 400 AS has_many_leaves FROM smol_inspect('t_tall_guc_idx');
 has_many_pages | has_many_leaves 
----------------+-----------------
 t              | t
(1 row)

-- Backward scan exercises smol_rightmost_in_subtree navigation
SELECT smol_test_backward_scan('t_tall_guc_idx'::regclass, 25000);
 smol_test_backward_scan 
-------------------------
                      10
(1 row)

RESET smol.test_max_tuples_per_page;
-- Cleanup
DROP TABLE t_cost CASCADE;
DROP TABLE t_large CASCADE;
DROP TABLE t_inc_sizes CASCADE;
DROP TABLE t_twocol_text CASCADE;
DROP TABLE t_twocol_uuid CASCADE;
DROP TABLE t_twocol_int2 CASCADE;
DROP TABLE t_twocol_int8 CASCADE;
DROP TABLE t_twocol_char CASCADE;
DROP TABLE t_empty_inspect CASCADE;
DROP TABLE t_no_parallel CASCADE;
DROP TABLE t_tall_guc CASCADE;
