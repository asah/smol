SET client_min_messages = warning;
CREATE EXTENSION IF NOT EXISTS smol;
-- Test runtime keys (non-native predicates) for coverage
-- Targets lines 2741-2742 (backward), 2770-2780 (forward ultra-fast), 2991-2994 (forward)
-- Runtime keys are needed for multi-column indexes with range predicates on the 2nd column
-- SMOL handles attribute 1 (leading key) natively, but attribute 2 range predicates need rechecking
SET client_min_messages = warning;
SET enable_seqscan = off;
SET enable_bitmapscan = off;
SET max_parallel_workers_per_gather = 0;
-- Create table with two key columns for multi-column index
DROP TABLE IF EXISTS t_runtime CASCADE;
CREATE UNLOGGED TABLE t_runtime (k1 int4, k2 int4, v int4);
-- Insert data: k1 in 1..100, k2 = k1*10, v = k1*100
INSERT INTO t_runtime SELECT i, i*10, i*100 FROM generate_series(1, 100) i;
ALTER TABLE t_runtime SET (autovacuum_enabled = off);
VACUUM (FREEZE, ANALYZE) t_runtime;
-- Multi-column index on (k1, k2) with INCLUDE(v)
CREATE INDEX t_runtime_idx ON t_runtime USING smol(k1, k2) INCLUDE (v);
-- Test 1: Forward scan with runtime keys that FAIL (lines 2991-2994)
-- k1=50 matches 1 row (k1=50, k2=500), but k2 > 600 fails, so runtime key returns false
SELECT k1, k2, v FROM t_runtime WHERE k1 = 50 AND k2 > 600;
 k1 | k2 | v 
----+----+---
(0 rows)

-- Test 2: Backward scan with runtime keys that FAIL (lines 2741-2742)
-- k1 in 51..60, but k2 < 550 only matches k1=51..54 (k2=510,520,530,540)
-- Backward scan checks k1=60,59,...,51 and runtime keys fail for k1=60..55
SELECT k1, k2 FROM t_runtime WHERE k1 > 50 AND k1 < 61 AND k2 < 550 ORDER BY k1 DESC;
 k1 | k2 
----+----
(0 rows)

-- Test 3: Forward scan with runtime keys on larger dataset
-- Tests runtime key evaluation with bound checks
DROP TABLE IF EXISTS t_larger CASCADE;
CREATE UNLOGGED TABLE t_larger (k1 int4, k2 int4, v int4);
INSERT INTO t_larger SELECT i, i*10, i*100 FROM generate_series(1, 5000) i;
VACUUM (FREEZE, ANALYZE) t_larger;
CREATE INDEX t_larger_idx ON t_larger USING smol(k1, k2) INCLUDE (v);
-- Query with runtime key k2 > 50000 fails for all rows (max k2 is 50000)
-- Must SELECT columns to force xs_want_itup=true (count(*) doesn't need tuples)
SELECT k1, k2, v FROM t_larger WHERE k1 >= 100 AND k2 > 50000 LIMIT 10;
 k1 | k2 | v 
----+----+---
(0 rows)

-- Also test with some runtime key successes
SELECT k1, k2, v FROM t_larger WHERE k1 >= 4990 AND k2 >= 49900 LIMIT 10;
  k1  |  k2   |   v    
------+-------+--------
 4990 | 49900 | 499000
 4991 | 49910 | 499100
 4992 | 49920 | 499200
 4993 | 49930 | 499300
 4994 | 49940 | 499400
 4995 | 49950 | 499500
 4996 | 49960 | 499600
 4997 | 49970 | 499700
 4998 | 49980 | 499800
 4999 | 49990 | 499900
(10 rows)

-- Cleanup
DROP TABLE t_runtime CASCADE;
DROP TABLE t_larger CASCADE;
