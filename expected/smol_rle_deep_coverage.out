-- Deep RLE coverage for remaining uncovered lines
-- Targets: 3565, 3588-3589, 3593, 3641, 3666-3667, 3671, 3713, 3718-3720
SET client_min_messages = warning;
CREATE EXTENSION IF NOT EXISTS smol;
-- ============================================================================
-- Test 1: Key-only RLE (0x8001) with INCLUDE columns present
-- This triggers lines 3718-3720: accessing includes when tag is 0x8001
-- ============================================================================
DROP TABLE IF EXISTS t_key_rle_with_inc CASCADE;
CREATE UNLOGGED TABLE t_key_rle_with_inc (k int8, v1 int4, v2 int4);
-- Insert data that creates key-only RLE
-- When keys are highly repetitive but we have includes, we might get 0x8001 + plain includes
INSERT INTO t_key_rle_with_inc
SELECT
    ((i / 1000) % 10)::int8 AS k,
    i AS v1,
    i * 2 AS v2
FROM generate_series(1, 50000) i;
CREATE INDEX t_key_rle_with_inc_smol ON t_key_rle_with_inc USING smol(k) INCLUDE (v1, v2);
-- Access data to trigger include pointer access in key-RLE format
SELECT k, v1, v2 FROM t_key_rle_with_inc WHERE k = 5 ORDER BY v1 LIMIT 10;
 k |  v1  |  v2   
---+------+-------
 5 | 5000 | 10000
 5 | 5001 | 10002
 5 | 5002 | 10004
 5 | 5003 | 10006
 5 | 5004 | 10008
 5 | 5005 | 10010
 5 | 5006 | 10012
 5 | 5007 | 10014
 5 | 5008 | 10016
 5 | 5009 | 10018
(10 rows)

SELECT k, count(*), sum(v1::int8), sum(v2::int8) FROM t_key_rle_with_inc WHERE k >= 3 GROUP BY k ORDER BY k;
 k | count |    sum    |    sum    
---+-------+-----------+-----------
 3 |  5000 | 117497500 | 234995000
 4 |  5000 | 122497500 | 244995000
 5 |  5000 | 127497500 | 254995000
 6 |  5000 | 132497500 | 264995000
 7 |  5000 | 137497500 | 274995000
 8 |  5000 | 142497500 | 284995000
 9 |  5000 | 147497500 | 294995000
(7 rows)

-- ============================================================================
-- Test 2: RLE with out-of-range index access (line 3565)
-- Need to create a situation where we scan beyond valid offsets
-- ============================================================================
DROP TABLE IF EXISTS t_rle_boundary_scan CASCADE;
CREATE UNLOGGED TABLE t_rle_boundary_scan (k int8, v int4);
-- Create small RLE runs
INSERT INTO t_rle_boundary_scan
SELECT
    ((i / 10) % 100)::int8 AS k,
    i AS v
FROM generate_series(1, 1000) i;
CREATE INDEX t_rle_boundary_scan_smol ON t_rle_boundary_scan USING smol(k) INCLUDE (v);
-- Scan to potentially trigger boundary conditions
SELECT k, v FROM t_rle_boundary_scan WHERE k >= 95 ORDER BY k, v;
 k  |  v  
----+-----
 95 | 950
 95 | 951
 95 | 952
 95 | 953
 95 | 954
 95 | 955
 95 | 956
 95 | 957
 95 | 958
 95 | 959
 96 | 960
 96 | 961
 96 | 962
 96 | 963
 96 | 964
 96 | 965
 96 | 966
 96 | 967
 96 | 968
 96 | 969
 97 | 970
 97 | 971
 97 | 972
 97 | 973
 97 | 974
 97 | 975
 97 | 976
 97 | 977
 97 | 978
 97 | 979
 98 | 980
 98 | 981
 98 | 982
 98 | 983
 98 | 984
 98 | 985
 98 | 986
 98 | 987
 98 | 988
 98 | 989
 99 | 990
 99 | 991
 99 | 992
 99 | 993
 99 | 994
 99 | 995
 99 | 996
 99 | 997
 99 | 998
 99 | 999
(50 rows)

SELECT k, count(*) FROM t_rle_boundary_scan GROUP BY k HAVING count(*) > 5 ORDER BY k;
 k  | count 
----+-------
  0 |    10
  1 |    10
  2 |    10
  3 |    10
  4 |    10
  5 |    10
  6 |    10
  7 |    10
  8 |    10
  9 |    10
 10 |    10
 11 |    10
 12 |    10
 13 |    10
 14 |    10
 15 |    10
 16 |    10
 17 |    10
 18 |    10
 19 |    10
 20 |    10
 21 |    10
 22 |    10
 23 |    10
 24 |    10
 25 |    10
 26 |    10
 27 |    10
 28 |    10
 29 |    10
 30 |    10
 31 |    10
 32 |    10
 33 |    10
 34 |    10
 35 |    10
 36 |    10
 37 |    10
 38 |    10
 39 |    10
 40 |    10
 41 |    10
 42 |    10
 43 |    10
 44 |    10
 45 |    10
 46 |    10
 47 |    10
 48 |    10
 49 |    10
 50 |    10
 51 |    10
 52 |    10
 53 |    10
 54 |    10
 55 |    10
 56 |    10
 57 |    10
 58 |    10
 59 |    10
 60 |    10
 61 |    10
 62 |    10
 63 |    10
 64 |    10
 65 |    10
 66 |    10
 67 |    10
 68 |    10
 69 |    10
 70 |    10
 71 |    10
 72 |    10
 73 |    10
 74 |    10
 75 |    10
 76 |    10
 77 |    10
 78 |    10
 79 |    10
 80 |    10
 81 |    10
 82 |    10
 83 |    10
 84 |    10
 85 |    10
 86 |    10
 87 |    10
 88 |    10
 89 |    10
 90 |    10
 91 |    10
 92 |    10
 93 |    10
 94 |    10
 95 |    10
 96 |    10
 97 |    10
 98 |    10
 99 |    10
(100 rows)

-- ============================================================================
-- Test 3: RLE key-RLE with single include (to hit specific code paths)
-- ============================================================================
DROP TABLE IF EXISTS t_keyrle_single_inc CASCADE;
CREATE UNLOGGED TABLE t_keyrle_single_inc (k int4, v int2);
-- Small include (int2 = 2 bytes) with repetitive keys
INSERT INTO t_keyrle_single_inc
SELECT
    ((i / 500) % 50)::int4 AS k,
    (i % 32767)::int2 AS v
FROM generate_series(1, 25000) i;
CREATE INDEX t_keyrle_single_inc_smol ON t_keyrle_single_inc USING smol(k) INCLUDE (v);
-- Query to access includes in potential key-RLE format
SELECT k, min(v), max(v), count(*) FROM t_keyrle_single_inc WHERE k BETWEEN 10 AND 15 GROUP BY k ORDER BY k;
 k  | min  | max  | count 
----+------+------+-------
 10 | 5000 | 5499 |   500
 11 | 5500 | 5999 |   500
 12 | 6000 | 6499 |   500
 13 | 6500 | 6999 |   500
 14 | 7000 | 7499 |   500
 15 | 7500 | 7999 |   500
(6 rows)

-- ============================================================================
-- Test 4: Multi-run RLE with many small runs (to test run iteration)
-- ============================================================================
DROP TABLE IF EXISTS t_multi_run CASCADE;
CREATE UNLOGGED TABLE t_multi_run (k int8, v1 int4, v2 int4, v3 int4);
-- Create many distinct runs (small runs, many of them)
INSERT INTO t_multi_run
SELECT
    ((i / 20) % 500)::int8 AS k,
    i AS v1,
    i * 2 AS v2,
    i * 3 AS v3
FROM generate_series(1, 10000) i;
CREATE INDEX t_multi_run_smol ON t_multi_run USING smol(k) INCLUDE (v1, v2, v3);
-- Access different parts of multi-run RLE
SELECT k, v1, v2, v3 FROM t_multi_run WHERE k = 250 ORDER BY v1 LIMIT 5;
  k  |  v1  |  v2   |  v3   
-----+------+-------+-------
 250 | 5000 | 10000 | 15000
 250 | 5001 | 10002 | 15003
 250 | 5002 | 10004 | 15006
 250 | 5003 | 10006 | 15009
 250 | 5004 | 10008 | 15012
(5 rows)

SELECT k, v1, v2, v3 FROM t_multi_run WHERE k = 100 ORDER BY v1 LIMIT 5;
  k  |  v1  |  v2  |  v3  
-----+------+------+------
 100 | 2000 | 4000 | 6000
 100 | 2001 | 4002 | 6003
 100 | 2002 | 4004 | 6006
 100 | 2003 | 4006 | 6009
 100 | 2004 | 4008 | 6012
(5 rows)

SELECT k, count(*) FROM t_multi_run WHERE k >= 400 GROUP BY k ORDER BY k LIMIT 10;
  k  | count 
-----+-------
 400 |    20
 401 |    20
 402 |    20
 403 |    20
 404 |    20
 405 |    20
 406 |    20
 407 |    20
 408 |    20
 409 |    20
(10 rows)

-- ============================================================================
-- Test 5: RLE with varying run lengths to test run detection edge cases
-- ============================================================================
DROP TABLE IF EXISTS t_varied_runs CASCADE;
CREATE UNLOGGED TABLE t_varied_runs (k int8, v1 int4, v2 int4);
-- Run 1: 100 rows
INSERT INTO t_varied_runs SELECT 1000, generate_series, generate_series * 2 FROM generate_series(1, 100);
-- Run 2: 1 row (singleton)
INSERT INTO t_varied_runs VALUES (2000, 101, 202);
-- Run 3: 500 rows
INSERT INTO t_varied_runs SELECT 3000, generate_series, generate_series * 2 FROM generate_series(102, 601);
-- Run 4: 2 rows
INSERT INTO t_varied_runs VALUES (4000, 602, 1204), (4000, 603, 1206);
-- Run 5: 1000 rows
INSERT INTO t_varied_runs SELECT 5000, generate_series, generate_series * 2 FROM generate_series(604, 1603);
CREATE INDEX t_varied_runs_smol ON t_varied_runs USING smol(k) INCLUDE (v1, v2);
-- Query each run type
SELECT k, count(*), min(v1), max(v1) FROM t_varied_runs WHERE k = 1000 GROUP BY k;  -- Medium run
  k   | count | min | max 
------+-------+-----+-----
 1000 |   100 |   1 | 100
(1 row)

SELECT k, count(*), min(v1), max(v1) FROM t_varied_runs WHERE k = 2000 GROUP BY k;  -- Singleton
  k   | count | min | max 
------+-------+-----+-----
 2000 |     1 | 101 | 101
(1 row)

SELECT k, count(*), min(v1), max(v1) FROM t_varied_runs WHERE k = 3000 GROUP BY k;  -- Large run
  k   | count | min | max 
------+-------+-----+-----
 3000 |   500 | 102 | 601
(1 row)

SELECT k, count(*), min(v1), max(v1) FROM t_varied_runs WHERE k = 4000 GROUP BY k;  -- Tiny run
  k   | count | min | max 
------+-------+-----+-----
 4000 |     2 | 602 | 603
(1 row)

SELECT k, count(*), min(v1), max(v1) FROM t_varied_runs WHERE k = 5000 GROUP BY k;  -- Very large run
  k   | count | min | max  
------+-------+-----+------
 5000 |  1000 | 604 | 1603
(1 row)

-- Scan across multiple runs
SELECT k, v1, v2 FROM t_varied_runs WHERE k >= 3000 AND v1 < 110 ORDER BY k, v1;
  k   | v1  | v2  
------+-----+-----
 3000 | 102 | 204
 3000 | 103 | 206
 3000 | 104 | 208
 3000 | 105 | 210
 3000 | 106 | 212
 3000 | 107 | 214
 3000 | 108 | 216
 3000 | 109 | 218
(8 rows)

-- ============================================================================
-- Test 6: RLE with text keys and multiple include columns
-- Test run detection with text (lines 3645, 3671)
-- ============================================================================
DROP TABLE IF EXISTS t_text_multirle CASCADE;
CREATE UNLOGGED TABLE t_text_multirle (k text COLLATE "C", v1 int4, v2 int4, v3 int2);
-- Create multiple runs with text keys
INSERT INTO t_text_multirle
SELECT
    'textkey' || lpad(((i / 30) % 100)::text, 3, '0') AS k,
    i AS v1,
    i * 2 AS v2,
    (i % 30000)::int2 AS v3
FROM generate_series(1, 3000) i;
CREATE INDEX t_text_multirle_smol ON t_text_multirle USING smol(k) INCLUDE (v1, v2, v3);
-- Query to test text run detection
SELECT k, count(*), min(v1) FROM t_text_multirle WHERE k >= 'textkey050' AND k <= 'textkey055' GROUP BY k ORDER BY k;
     k      | count | min  
------------+-------+------
 textkey050 |    30 | 1500
 textkey051 |   150 | 1530
(2 rows)

SELECT k, v1, v2, v3 FROM t_text_multirle WHERE k = 'textkey025' ORDER BY v1 LIMIT 5;
     k      | v1  |  v2  | v3  
------------+-----+------+-----
 textkey025 | 750 | 1500 | 750
 textkey025 | 751 | 1502 | 751
 textkey025 | 752 | 1504 | 752
 textkey025 | 753 | 1506 | 753
 textkey025 | 754 | 1508 | 754
(5 rows)

-- ============================================================================
-- Test 7: Key-RLE (0x8001) without includes - pure key compression
-- ============================================================================
DROP TABLE IF EXISTS t_pure_key_rle CASCADE;
CREATE UNLOGGED TABLE t_pure_key_rle (k int8);
-- Extremely repetitive keys, no includes
INSERT INTO t_pure_key_rle
SELECT ((i / 10000) % 5)::int8 FROM generate_series(1, 50000) i;
CREATE INDEX t_pure_key_rle_smol ON t_pure_key_rle USING smol(k);
-- Query pure key RLE
SELECT k, count(*) FROM t_pure_key_rle GROUP BY k ORDER BY k;
 k | count 
---+-------
 0 | 10000
 1 | 10000
 2 | 10000
 3 | 10000
 4 | 10000
(5 rows)

SELECT k FROM t_pure_key_rle WHERE k = 2 LIMIT 100;
 k 
---
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
 2
(100 rows)

-- Cleanup
DROP TABLE t_key_rle_with_inc CASCADE;
DROP TABLE t_rle_boundary_scan CASCADE;
DROP TABLE t_keyrle_single_inc CASCADE;
DROP TABLE t_multi_run CASCADE;
DROP TABLE t_varied_runs CASCADE;
DROP TABLE t_text_multirle CASCADE;
DROP TABLE t_pure_key_rle CASCADE;
