-- Test to achieve final 100% code coverage
-- Covers utility functions, edge cases, and remaining uncovered branches
SET smol.key_rle_version = 'v2';
SET client_min_messages = warning;
CREATE EXTENSION IF NOT EXISTS smol;
-- Test 1: Enable debug log to trigger smol_log_page_summary and smol_hex
SET smol.debug_log = on;
-- Create a small index to trigger smol_log_page_summary (single leaf case)
DROP TABLE IF EXISTS t_debug CASCADE;
CREATE UNLOGGED TABLE t_debug (k int4);
INSERT INTO t_debug SELECT i FROM generate_series(1, 10) i;
CREATE INDEX t_debug_idx ON t_debug USING smol(k);
-- Test 2: Trigger smol_cmp_keyptr_to_bound with int2 (fast path line 702-705)
DROP TABLE IF EXISTS t_int2_bound CASCADE;
CREATE UNLOGGED TABLE t_int2_bound (k int2);
INSERT INTO t_int2_bound SELECT i::int2 FROM generate_series(1, 100) i;
CREATE INDEX t_int2_bound_idx ON t_int2_bound USING smol(k);
-- Query that uses lower bound comparison with int2
SELECT count(*) FROM t_int2_bound WHERE k > 50::int2;
 count 
-------
    50
(1 row)

-- Test 3: Trigger smol_cmp_keyptr_to_bound generic fallback (line 721)
-- Need a type that isn't int2/int4/int8/text - use "char"
DROP TABLE IF EXISTS t_char_bound CASCADE;
CREATE UNLOGGED TABLE t_char_bound (k "char");
INSERT INTO t_char_bound SELECT i::"char" FROM generate_series(1, 100) i;
CREATE INDEX t_char_bound_idx ON t_char_bound USING smol(k);
-- Query that uses lower bound comparison with "char"
SELECT count(*) FROM t_char_bound WHERE k > 50::"char";
 count 
-------
    50
(1 row)

-- Test 4: Trigger smol_copy_small with various INCLUDE column sizes
-- Need fixed-length types of sizes 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
DROP TABLE IF EXISTS t_copy_sizes CASCADE;
CREATE UNLOGGED TABLE t_copy_sizes (
    k int4,
    v2 int2,          -- 2 bytes (case 2)
    v4 int4,          -- 4 bytes (case 4)
    v8 int8,          -- 8 bytes (case 8)
    v16 uuid          -- 16 bytes (case 16)
);
INSERT INTO t_copy_sizes
SELECT i, (i*2)::int2, i*4, (i*8)::int8, gen_random_uuid()
FROM generate_series(1, 100) i;
-- Create index with INCLUDE to trigger smol_copy_small
CREATE INDEX t_copy_sizes_idx ON t_copy_sizes USING smol(k) INCLUDE (v2, v4, v8, v16);
-- Backward scan to trigger INCLUDE column copying (smol_scan.c:1284-1285)
SELECT k, v2, v4, v8 FROM t_copy_sizes WHERE k > 90 ORDER BY k DESC LIMIT 5;
  k  | v2  | v4  | v8  
-----+-----+-----+-----
 100 | 200 | 400 | 800
  99 | 198 | 396 | 792
  98 | 196 | 392 | 784
  97 | 194 | 388 | 776
  96 | 192 | 384 | 768
(5 rows)

-- Test 5: Create multi-level tree with debug logging to trigger smol_log_page_summary (multi-level case)
DROP TABLE IF EXISTS t_multilevel_debug CASCADE;
CREATE UNLOGGED TABLE t_multilevel_debug (k int4);
-- Insert enough data to create multi-level tree
INSERT INTO t_multilevel_debug SELECT i FROM generate_series(1, 100000) i;
CREATE INDEX t_multilevel_debug_idx ON t_multilevel_debug USING smol(k);
-- This should trigger smol_log_page_summary at line 1228
-- Disable debug log
SET smol.debug_log = off;
-- Test 6: Trigger smol_scan.c:90-91 upper bound stop scan path
-- This requires using smol.test_force_page_bounds_check to inject a fake upper bound
-- The test hook at smol_scan.c:560-568 creates a fake upper bound at 10000
-- for data with gaps (1-5000, then 100000+)
DROP TABLE IF EXISTS t_upper_bound_stop CASCADE;
CREATE UNLOGGED TABLE t_upper_bound_stop (k int4);
-- Insert data with a gap to match the test hook's expectation
-- 1-5000 will be on early pages, 100000+ will be on later pages
INSERT INTO t_upper_bound_stop SELECT i FROM generate_series(1, 5000) i;
INSERT INTO t_upper_bound_stop SELECT i FROM generate_series(100000, 105000) i;
CREATE INDEX t_upper_bound_stop_idx ON t_upper_bound_stop USING smol(k);
-- Enable test GUC to inject fake upper bound
SET smol.test_force_page_bounds_check = on;
-- Query WITHOUT explicit upper bound - the test hook will inject one at 10000
-- This triggers page-level bounds check at smol_scan.c:85-92
-- When scan reaches page with k=100000, first_key (100000) > fake_upper_bound (10000)
-- so stop_scan_out is set to true at line 90
SELECT count(*) FROM t_upper_bound_stop WHERE k > 0;
 count 
-------
  5000
(1 row)

-- Cleanup
DROP TABLE t_debug CASCADE;
DROP TABLE t_int2_bound CASCADE;
DROP TABLE t_char_bound CASCADE;
DROP TABLE t_copy_sizes CASCADE;
DROP TABLE t_multilevel_debug CASCADE;
DROP TABLE t_upper_bound_stop CASCADE;
