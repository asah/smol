-- Test Include-RLE run comparison mismatch (line 3457)
CREATE EXTENSION IF NOT EXISTS smol;
NOTICE:  extension "smol" already exists, skipping
DROP TABLE IF EXISTS t_rle_mismatch CASCADE;
NOTICE:  table "t_rle_mismatch" does not exist, skipping
CREATE UNLOGGED TABLE t_rle_mismatch (k text, v int4);
-- Insert rows with same key but different include values
-- This should trigger the include mismatch check in RLE encoding
INSERT INTO t_rle_mismatch VALUES
    ('key1', 1),
    ('key1', 2),  -- Same key, different include
    ('key1', 3),  -- Same key, different include
    ('key2', 4),
    ('key2', 5);  -- Same key, different include
CREATE INDEX idx_rle_mismatch ON t_rle_mismatch USING smol(k) INCLUDE (v);
-- Verify index works
SELECT * FROM t_rle_mismatch WHERE k = 'key1' ORDER BY v;
  k   | v 
------+---
 key1 | 1
 key1 | 2
 key1 | 3
(3 rows)

DROP TABLE t_rle_mismatch CASCADE;
-- Test multi-column include with RLE run break on second column (line 3457)
-- This specifically targets the inner loop that checks include value mismatches
-- Need MANY duplicate keys to trigger Include-RLE format (not RLE format)
DROP TABLE IF EXISTS t_multi_inc CASCADE;
NOTICE:  table "t_multi_inc" does not exist, skipping
CREATE UNLOGGED TABLE t_multi_inc (k text, v1 int4, v2 int4);
-- Insert rows where:
-- - Key is same (triggers RLE)
-- - First include column matches
-- - Second include column differs mid-run (triggers line 3457)
-- The RLE algorithm compares row 0 with rows 1, 2, 3...
-- To ensure Include-RLE format is used, need many duplicates
INSERT INTO t_multi_inc
SELECT
    'key' || (i % 10)::text,  -- 10 distinct keys
    100,                        -- v1 always 100
    CASE WHEN i % 100 = 50 THEN 999 ELSE i % 10 END  -- v2 differs at position 50, 150, 250...
FROM generate_series(1, 1000) i
ORDER BY 1, 2, 3;
CREATE INDEX idx_multi_inc ON t_multi_inc USING smol(k) INCLUDE (v1, v2);
-- Verify index works
SELECT COUNT(*) FROM t_multi_inc WHERE k = 'key1';
 count 
-------
   100
(1 row)

DROP TABLE t_multi_inc CASCADE;
