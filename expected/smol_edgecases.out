SET client_min_messages = warning;
CREATE EXTENSION IF NOT EXISTS smol;
-- SMOL edge-case correctness checks (kept separate from REGRESS)
-- Run manually: psql -f sql/smol_edgecases.sql
-- All tests are small and fast; they exercise boundaries, duplicates,
-- page chains, backward scans, rescans, and two-column equality filters.
SET client_min_messages = warning;
-- 1) Empty and single-leaf trees (compare vs BTREE)
DROP TABLE IF EXISTS e1 CASCADE; CREATE UNLOGGED TABLE e1(a int);
CREATE INDEX e1_bt ON e1 USING btree(a);
SET enable_seqscan=off; SELECT count(*) AS empty_bt_count FROM e1 WHERE a >= 0; \gset
 empty_bt_count 
----------------
              0
(1 row)

DROP INDEX e1_bt;
CREATE INDEX e1_smol ON e1 USING smol(a);
SET enable_seqscan=off; SET enable_indexonlyscan=on; SET enable_indexscan=off;
SELECT count(*) AS empty_sm_count FROM e1 WHERE a >= 0; \gset
 empty_sm_count 
----------------
              0
(1 row)

SELECT (:'empty_bt_count' = :'empty_sm_count') AS empty_match;
 empty_match 
-------------
 t
(1 row)

DROP INDEX e1_smol;
DROP TABLE IF EXISTS s1 CASCADE; CREATE UNLOGGED TABLE s1(a int);
INSERT INTO s1 SELECT i FROM generate_series(1,1000) i;  -- should fit 1 leaf
-- BTREE baseline
CREATE INDEX s1_bt ON s1 USING btree(a);
SET enable_seqscan=off; SET enable_bitmapscan=off; SET enable_indexonlyscan=on; SET enable_indexscan=on;
SELECT md5(array_to_string(array_agg(a ORDER BY a), ',')) AS s1_bt_asc FROM s1 WHERE a >= 990; \gset
            s1_bt_asc             
----------------------------------
 9c0b405931b8d287f6d73da323145f44
(1 row)

SELECT md5(array_to_string(array_agg(a ORDER BY a DESC), ',')) AS s1_bt_desc FROM s1 WHERE a >= 990; \gset
            s1_bt_desc            
----------------------------------
 95fac0f08f50649ac71a4e33d46633d3
(1 row)

DROP INDEX s1_bt;
-- SMOL
CREATE INDEX s1_smol ON s1 USING smol(a);
SET enable_indexscan=off;  -- SMOL requires IOS
SELECT md5(array_to_string(array_agg(a ORDER BY a), ',')) AS s1_sm_asc FROM s1 WHERE a >= 990; \gset
            s1_sm_asc             
----------------------------------
 9c0b405931b8d287f6d73da323145f44
(1 row)

SELECT md5(array_to_string(array_agg(a ORDER BY a DESC), ',')) AS s1_sm_desc FROM s1 WHERE a >= 990; \gset
            s1_sm_desc            
----------------------------------
 95fac0f08f50649ac71a4e33d46633d3
(1 row)

SELECT (:'s1_bt_asc' = :'s1_sm_asc') AS s1_asc_match,
       (:'s1_bt_desc' = :'s1_sm_desc') AS s1_desc_match;
 s1_asc_match | s1_desc_match 
--------------+---------------
 t            | t
(1 row)

-- 2) Boundaries/negatives (int2) vs BTREE
DROP TABLE IF EXISTS b1 CASCADE; CREATE UNLOGGED TABLE b1(a int2);
INSERT INTO b1 VALUES (('-32768')::int2),(-1::int2),(0::int2),(1::int2),(32767::int2);
-- BTREE
CREATE INDEX b1_bt ON b1 USING btree(a);
SET enable_seqscan=off; SET enable_bitmapscan=off; SET enable_indexonlyscan=on; SET enable_indexscan=on;
SELECT md5(array_to_string(array_agg(a ORDER BY a), ',')) AS b1_bt_ge_neg1 FROM b1 WHERE a >= -1; \gset
          b1_bt_ge_neg1           
----------------------------------
 26527f4251fe769477d440a23b198a30
(1 row)

SELECT md5(array_to_string(array_agg(a ORDER BY a), ',')) AS b1_bt_gt_neg1 FROM b1 WHERE a > -1;  \gset
          b1_bt_gt_neg1           
----------------------------------
 21e814bb1112016cce59147c6cc3de6c
(1 row)

SELECT md5(array_to_string(array_agg(a ORDER BY a), ',')) AS b1_bt_ge_max  FROM b1 WHERE a >= 32767; \gset
           b1_bt_ge_max           
----------------------------------
 7cf91b300ff3ecef82c59dd47b89253a
(1 row)

SELECT count(*) AS b1_bt_gt_max0 FROM b1 WHERE a > 32767; \gset
 b1_bt_gt_max0 
---------------
             0
(1 row)

DROP INDEX b1_bt;
-- SMOL
CREATE INDEX b1_smol ON b1 USING smol(a);
SET enable_indexscan=off;
SELECT md5(array_to_string(array_agg(a ORDER BY a), ',')) AS b1_sm_ge_neg1 FROM b1 WHERE a >= -1; \gset
          b1_sm_ge_neg1           
----------------------------------
 26527f4251fe769477d440a23b198a30
(1 row)

SELECT md5(array_to_string(array_agg(a ORDER BY a), ',')) AS b1_sm_gt_neg1 FROM b1 WHERE a > -1;  \gset
          b1_sm_gt_neg1           
----------------------------------
 21e814bb1112016cce59147c6cc3de6c
(1 row)

SELECT md5(array_to_string(array_agg(a ORDER BY a), ',')) AS b1_sm_ge_max  FROM b1 WHERE a >= 32767; \gset
           b1_sm_ge_max           
----------------------------------
 7cf91b300ff3ecef82c59dd47b89253a
(1 row)

SELECT count(*) AS b1_sm_gt_max0 FROM b1 WHERE a > 32767; \gset
 b1_sm_gt_max0 
---------------
             0
(1 row)

SELECT (:'b1_bt_ge_neg1' = :'b1_sm_ge_neg1') AS b1_ge_neg1_match,
       (:'b1_bt_gt_neg1' = :'b1_sm_gt_neg1') AS b1_gt_neg1_match,
       (:'b1_bt_ge_max'  = :'b1_sm_ge_max')  AS b1_ge_max_match,
       (:'b1_bt_gt_max0' = :'b1_sm_gt_max0') AS b1_gt_max0_match;
 b1_ge_neg1_match | b1_gt_neg1_match | b1_ge_max_match | b1_gt_max0_match 
------------------+------------------+-----------------+------------------
 t                | t                | t               | t
(1 row)

-- 3) Duplicates and page-crossing duplicates vs BTREE
DROP TABLE IF EXISTS d1 CASCADE; CREATE UNLOGGED TABLE d1(a int);
INSERT INTO d1 SELECT 42 FROM generate_series(1,20000);
INSERT INTO d1 SELECT 7  FROM generate_series(1,10000);
-- BTREE
CREATE INDEX d1_bt ON d1 USING btree(a);
SET enable_seqscan=off; SET enable_bitmapscan=off; SET enable_indexonlyscan=on; SET enable_indexscan=on;
SELECT count(*) AS d1_bt_ge7 FROM d1 WHERE a >= 7; \gset
 d1_bt_ge7 
-----------
     30000
(1 row)

SELECT count(*) AS d1_bt_eq42 FROM d1 WHERE a = 42; \gset
 d1_bt_eq42 
------------
      20000
(1 row)

SELECT array_agg(a ORDER BY a DESC) AS d1_bt_top5 FROM (SELECT a FROM d1 WHERE a >= 7 ORDER BY a DESC LIMIT 5) s; \gset
    d1_bt_top5    
------------------
 {42,42,42,42,42}
(1 row)

DROP INDEX d1_bt;
-- SMOL
CREATE INDEX d1_smol ON d1 USING smol(a);
SET enable_indexscan=off;
SELECT count(*) AS d1_sm_ge7 FROM d1 WHERE a >= 7; \gset
 d1_sm_ge7 
-----------
     30000
(1 row)

SELECT count(*) AS d1_sm_eq42 FROM d1 WHERE a = 42; \gset
 d1_sm_eq42 
------------
      20000
(1 row)

SELECT array_agg(a ORDER BY a DESC) AS d1_sm_top5 FROM (SELECT a FROM d1 WHERE a >= 7 ORDER BY a DESC LIMIT 5) s; \gset
    d1_sm_top5    
------------------
 {42,42,42,42,42}
(1 row)

SELECT (:'d1_bt_ge7' = :'d1_sm_ge7')   AS d1_ge7_match,
       (:'d1_bt_eq42' = :'d1_sm_eq42') AS d1_eq42_match,
       (:'d1_bt_top5' = :'d1_sm_top5') AS d1_top5_match;
 d1_ge7_match | d1_eq42_match | d1_top5_match 
--------------+---------------+---------------
 t            | t             | t
(1 row)

-- 4) Two-column equality on second key vs BTREE
DROP TABLE IF EXISTS t2 CASCADE; CREATE UNLOGGED TABLE t2(a int2, b int2);
INSERT INTO t2 SELECT (i % 100)::int2, (i % 5)::int2 FROM generate_series(1,20000) i;
-- BTREE baseline (INCLUDE to match IOS behavior)
CREATE INDEX t2_bt ON t2 USING btree(b) INCLUDE (a);
SET enable_seqscan=off; SET enable_bitmapscan=off; SET enable_indexonlyscan=on; SET enable_indexscan=on;
DROP TABLE IF EXISTS res_t2; CREATE TEMP TABLE res_t2(s bigint);
INSERT INTO res_t2 SELECT sum(a)::bigint FROM t2 WHERE b > 2 AND a = 17;
DROP INDEX t2_bt;
-- SMOL
CREATE INDEX t2_smol ON t2 USING smol(b,a);
SET enable_indexscan=off;  -- SMOL IOS only
SELECT (SELECT s FROM res_t2 LIMIT 1) IS NOT DISTINCT FROM (SELECT sum(a)::bigint FROM t2 WHERE b > 2 AND a = 17) AS t2_eq_match;
 t2_eq_match 
-------------
 t
(1 row)

-- 4b) Large-group equality stress: many rows share the same b, sparse equals on a
DROP TABLE IF EXISTS t2g CASCADE; CREATE UNLOGGED TABLE t2g(a int4, b int4);
-- Build large groups on b: repeat each b value many times; set a to i%10000 for spread
INSERT INTO t2g
SELECT (i % 10000)::int4 AS a, (i / 1000)::int4 AS b
FROM generate_series(0, 199999) AS i;  -- 200k rows, b has 200 groups of size ~1000
-- BTREE baseline
CREATE INDEX t2g_bt ON t2g USING btree(b) INCLUDE (a);
SET enable_seqscan=off; SET enable_bitmapscan=off; SET enable_indexonlyscan=on; SET enable_indexscan=on;
DROP TABLE IF EXISTS res_t2g; CREATE TEMP TABLE res_t2g(s bigint, c bigint);
INSERT INTO res_t2g SELECT COALESCE(sum(a),0)::bigint, count(*)::bigint FROM t2g WHERE b = 42 AND a = 777;
DROP INDEX t2g_bt;
-- SMOL
CREATE INDEX t2g_smol ON t2g USING smol(b,a);
SET enable_indexscan=off;  -- SMOL IOS only
SELECT ((SELECT s FROM res_t2g) = (SELECT COALESCE(sum(a),0)::bigint FROM t2g WHERE b = 42 AND a = 777)
        AND (SELECT c FROM res_t2g) = (SELECT count(*)::bigint FROM t2g WHERE b = 42 AND a = 777)) AS t2g_eq_match;
 t2g_eq_match 
--------------
 t
(1 row)

-- 5) No-match/out-of-range vs BTREE
DROP TABLE IF EXISTS nm CASCADE; CREATE UNLOGGED TABLE nm(a int8);
INSERT INTO nm SELECT i::bigint FROM generate_series(1,10000) i;
-- BTREE
CREATE INDEX nm_bt ON nm USING btree(a);
SET enable_seqscan=off; SET enable_bitmapscan=off; SET enable_indexonlyscan=on; SET enable_indexscan=on;
SELECT count(*) AS nm_bt_big FROM nm WHERE a > 1000000000000; \gset
 nm_bt_big 
-----------
         0
(1 row)

SELECT count(*) AS nm_bt_neg FROM nm WHERE a = -1; \gset
 nm_bt_neg 
-----------
         0
(1 row)

DROP INDEX nm_bt;
-- SMOL
CREATE INDEX nm_smol ON nm USING smol(a);
SET enable_indexscan=off;
SELECT count(*) AS nm_sm_big FROM nm WHERE a > 1000000000000; \gset
 nm_sm_big 
-----------
         0
(1 row)

SELECT count(*) AS nm_sm_neg FROM nm WHERE a = -1; \gset
 nm_sm_neg 
-----------
         0
(1 row)

SELECT (:'nm_bt_big' = :'nm_sm_big') AS nm_big_match,
       (:'nm_bt_neg' = :'nm_sm_neg') AS nm_neg_match;
 nm_big_match | nm_neg_match 
--------------+--------------
 t            | t
(1 row)

-- 6) Rescan behavior via PREPARE (compare counts)
DROP TABLE IF EXISTS rs CASCADE; CREATE UNLOGGED TABLE rs(a int);
INSERT INTO rs SELECT i FROM generate_series(1,10000) i;
-- BTREE
CREATE INDEX rs_bt ON rs USING btree(a);
SET enable_seqscan=off; SET enable_bitmapscan=off; SET enable_indexonlyscan=on; SET enable_indexscan=on;
PREPARE qbt(int) AS SELECT count(*) FROM rs WHERE a >= $1;
EXECUTE qbt(9000); \gset
 count 
-------
  1001
(1 row)

EXECUTE qbt(9500); \gset
 count 
-------
   501
(1 row)

EXECUTE qbt(1);    \gset
 count 
-------
 10000
(1 row)

DROP INDEX rs_bt;
-- SMOL
CREATE INDEX rs_smol ON rs USING smol(a);
SET enable_indexscan=off; SET enable_indexonlyscan=on;
PREPARE qsm(int) AS SELECT count(*) FROM rs WHERE a >= $1;
EXECUTE qsm(9000); \gset
 count 
-------
  1001
(1 row)

EXECUTE qsm(9500); \gset
 count 
-------
   501
(1 row)

EXECUTE qsm(1);    \gset
 count 
-------
 10000
(1 row)

SELECT (:'count' = :'count') AS rs_9000_match;  -- last assignment reused; keep explicit checks below
 rs_9000_match 
---------------
 t
(1 row)

-- Explicit matches for captured results
-- Re-run quickly to bind into named vars
SELECT count(*) AS rs_bt_9000 FROM rs WHERE a >= 9000; \gset
 rs_bt_9000 
------------
       1001
(1 row)

SELECT count(*) AS rs_sm_9000 FROM rs WHERE a >= 9000; \gset
 rs_sm_9000 
------------
       1001
(1 row)

SELECT count(*) AS rs_bt_9500 FROM rs WHERE a >= 9500; \gset
 rs_bt_9500 
------------
        501
(1 row)

SELECT count(*) AS rs_sm_9500 FROM rs WHERE a >= 9500; \gset
 rs_sm_9500 
------------
        501
(1 row)

SELECT count(*) AS rs_bt_1    FROM rs WHERE a >= 1;    \gset
 rs_bt_1 
---------
   10000
(1 row)

SELECT count(*) AS rs_sm_1    FROM rs WHERE a >= 1;    \gset
 rs_sm_1 
---------
   10000
(1 row)

SELECT (:'rs_bt_9000' = :'rs_sm_9000') AS rs_9000_match,
       (:'rs_bt_9500' = :'rs_sm_9500') AS rs_9500_match,
       (:'rs_bt_1'    = :'rs_sm_1')    AS rs_1_match;
 rs_9000_match | rs_9500_match | rs_1_match 
---------------+---------------+------------
 t             | t             | t
(1 row)

-- 7) Backward scan parity vs BTREE
DROP TABLE IF EXISTS bw CASCADE; CREATE UNLOGGED TABLE bw(a int);
INSERT INTO bw SELECT i FROM generate_series(1,2000) i;
-- BTREE
CREATE INDEX bw_bt ON bw USING btree(a);
SET enable_seqscan=off; SET enable_bitmapscan=off; SET enable_indexonlyscan=on; SET enable_indexscan=on;
SELECT array_agg(a ORDER BY a DESC) AS bw_bt_back20 FROM (SELECT a FROM bw WHERE a >= 1500 ORDER BY a DESC LIMIT 20) s1; \gset
                                             bw_bt_back20                                              
-------------------------------------------------------------------------------------------------------
 {2000,1999,1998,1997,1996,1995,1994,1993,1992,1991,1990,1989,1988,1987,1986,1985,1984,1983,1982,1981}
(1 row)

SELECT array_agg(a ORDER BY a ASC)  AS bw_bt_forw20 FROM (SELECT a FROM bw WHERE a >= 1500 ORDER BY a ASC LIMIT 20) s2;  \gset
                                             bw_bt_forw20                                              
-------------------------------------------------------------------------------------------------------
 {1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519}
(1 row)

DROP INDEX bw_bt;
-- SMOL
CREATE INDEX bw_smol ON bw USING smol(a);
SET enable_indexscan=off;
SELECT array_agg(a ORDER BY a DESC) AS bw_sm_back20 FROM (SELECT a FROM bw WHERE a >= 1500 ORDER BY a DESC LIMIT 20) s1; \gset
                                             bw_sm_back20                                              
-------------------------------------------------------------------------------------------------------
 {2000,1999,1998,1997,1996,1995,1994,1993,1992,1991,1990,1989,1988,1987,1986,1985,1984,1983,1982,1981}
(1 row)

SELECT array_agg(a ORDER BY a ASC)  AS bw_sm_forw20 FROM (SELECT a FROM bw WHERE a >= 1500 ORDER BY a ASC LIMIT 20) s2;  \gset
                                             bw_sm_forw20                                              
-------------------------------------------------------------------------------------------------------
 {1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519}
(1 row)

SELECT (:'bw_bt_back20' = :'bw_sm_back20') AS bw_back_match,
       (:'bw_bt_forw20' = :'bw_sm_forw20') AS bw_forw_match;
 bw_back_match | bw_forw_match 
---------------+---------------
 t             | t
(1 row)

-- 8) Non-leading-key plan safety (compare vs BTREE on (a,b) and (b,a))
DROP TABLE IF EXISTS nl CASCADE; CREATE UNLOGGED TABLE nl(a int, b int);
INSERT INTO nl SELECT (i % 10), i FROM generate_series(1,5000) i;
-- BTREE baseline (use (b,a) to best match query)
CREATE INDEX nl_bt ON nl USING btree(b,a);
SET enable_seqscan=off; SET enable_bitmapscan=off; SET enable_indexonlyscan=on; SET enable_indexscan=on;
SELECT (SELECT b FROM nl WHERE b = 1234 ORDER BY a LIMIT 1) AS nl_bt_row; \gset
 nl_bt_row 
-----------
      1234
(1 row)

DROP INDEX nl_bt;
-- SMOL on (b,a)
CREATE INDEX nl_smol ON nl USING smol(b,a);
SET enable_indexscan=off; SET enable_indexonlyscan=on;
SELECT (SELECT b FROM nl WHERE b = 1234 ORDER BY a LIMIT 1) AS nl_sm_row; \gset
 nl_sm_row 
-----------
      1234
(1 row)

SELECT (:'nl_bt_row' = :'nl_sm_row') AS nl_nonleading_match;
 nl_nonleading_match 
---------------------
 t
(1 row)

