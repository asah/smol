-- Parallel scan test - forces parallel index-only scan execution
-- Requires large enough data and proper parallel settings
SET client_min_messages = warning;
CREATE EXTENSION IF NOT EXISTS smol;
-- Create large table to justify parallelism
DROP TABLE IF EXISTS t_para CASCADE;
CREATE UNLOGGED TABLE t_para(k int4, v int4);
-- Insert 500k rows to make parallelism worthwhile
INSERT INTO t_para SELECT i, i*2 FROM generate_series(1, 500000) i;
-- Critical: ANALYZE to get accurate statistics for planner
ANALYZE t_para;
CREATE INDEX t_para_smol ON t_para USING smol(k) INCLUDE (v);
-- Force parallel execution settings
SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;
SET parallel_tuple_cost = 0;
SET min_parallel_table_scan_size = 0;
SET min_parallel_index_scan_size = 0;
SET debug_parallel_query = on;  -- Force parallel mode in PG18+
SET enable_seqscan = off;
SET enable_bitmapscan = off;
SET enable_indexonlyscan = on;
SET enable_indexscan = off;
-- Run parallel query - large enough to trigger parallel workers
-- Query returns actual data to verify correctness
SELECT count(*), sum(v)::bigint, min(k), max(k)
FROM t_para
WHERE k >= 10000;
 count  |     sum      |  min  |  max   
--------+--------------+-------+--------
 490001 | 249900510000 | 10000 | 500000
(1 row)

-- Run another parallel query with different selectivity
SELECT count(*), sum(k)::bigint
FROM t_para
WHERE k >= 100000 AND k < 400000;
 count  |     sum     
--------+-------------
 300000 | 74999850000
(1 row)

-- Test with equality on specific range to test parallel claim batches
SELECT count(*), sum(v)::bigint
FROM t_para
WHERE k >= 250000;
 count  |     sum      
--------+--------------
 250001 | 187500750000
(1 row)

-- Test parallel batch claiming (lines 2231-2247)
-- Set batch size > 1 to trigger multi-leaf claiming logic
SET smol.parallel_claim_batch = 4;
SELECT count(*), sum(v)::bigint
FROM t_para
WHERE k >= 100000;
 count  |     sum      
--------+--------------
 400001 | 240000600000
(1 row)

SET smol.parallel_claim_batch = 1;
-- Test parallel rescan (lines 2450-2457)
BEGIN;
DECLARE c1 CURSOR FOR SELECT count(*) FROM t_para WHERE k >= 50000;
FETCH 1 FROM c1;
 count  
--------
 450001
(1 row)

CLOSE c1;
DECLARE c1 CURSOR FOR SELECT count(*) FROM t_para WHERE k >= 50000;
FETCH 1 FROM c1;
 count  
--------
 450001
(1 row)

CLOSE c1;
COMMIT;
-- Reset parallel settings
SET max_parallel_workers_per_gather = 0;
SET debug_parallel_query = off;
DROP INDEX t_para_smol;
DROP TABLE t_para;
-- Test parallel scan with int8 keys
DROP TABLE IF EXISTS t_para_int8 CASCADE;
CREATE UNLOGGED TABLE t_para_int8(k int8, v int4);
INSERT INTO t_para_int8 SELECT i::int8, i::int4 FROM generate_series(1, 500000) i;
ANALYZE t_para_int8;
CREATE INDEX t_para_int8_smol ON t_para_int8 USING smol(k) INCLUDE (v);
-- Enable parallel
SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;
SET parallel_tuple_cost = 0;
SET min_parallel_table_scan_size = 0;
SET min_parallel_index_scan_size = 0;
SET debug_parallel_query = on;
SET enable_seqscan = off;
SET enable_bitmapscan = off;
SET enable_indexonlyscan = on;
SET enable_indexscan = off;
SELECT count(*), sum(v)::bigint
FROM t_para_int8
WHERE k >= 200000::int8;
 count  |     sum      
--------+--------------
 300001 | 105000350000
(1 row)

SET max_parallel_workers_per_gather = 0;
SET debug_parallel_query = off;
DROP INDEX t_para_int8_smol;
DROP TABLE t_para_int8;
-- Test CAS failure retry path (line 1593) - force atomic contention
-- This simulates parallel workers racing to claim the first block
DROP TABLE IF EXISTS t_cas_retry CASCADE;
CREATE UNLOGGED TABLE t_cas_retry(k int4, v int4);
INSERT INTO t_cas_retry SELECT i, i*3 FROM generate_series(1, 100000) i;
ANALYZE t_cas_retry;
CREATE INDEX t_cas_retry_smol ON t_cas_retry USING smol(k) INCLUDE (v);
-- Note: CAS retry path (line ~1700) cannot be reliably tested
-- Requires precise parallel worker timing that's impossible to simulate deterministically
-- Enable parallel
SET max_parallel_workers_per_gather = 4;
SET parallel_setup_cost = 0;
SET parallel_tuple_cost = 0;
SET min_parallel_table_scan_size = 0;
SET min_parallel_index_scan_size = 0;
SET debug_parallel_query = on;
SET enable_seqscan = off;
SET enable_bitmapscan = off;
SET enable_indexonlyscan = on;
SET enable_indexscan = off;
-- Run query - the CAS failure will force retry loop
SELECT count(*), sum(v)::bigint, min(k), max(k)
FROM t_cas_retry
WHERE k >= 10000;
 count |     sum     |  min  |  max   
-------+-------------+-------+--------
 90001 | 14850165000 | 10000 | 100000
(1 row)

-- Reset
SET max_parallel_workers_per_gather = 0;
SET debug_parallel_query = off;
DROP INDEX t_cas_retry_smol;
DROP TABLE t_cas_retry;
