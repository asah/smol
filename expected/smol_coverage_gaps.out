SET client_min_messages = warning;
CREATE EXTENSION IF NOT EXISTS smol;
-- Test to cover remaining coverage gaps
-- Covers: Text RLE, UUID RLE, RLE INCLUDE caching
-- Test 1: Text RLE with heavy duplicates (covers lines 5307-5342)
CREATE UNLOGGED TABLE test_text_rle(k text COLLATE "C", v int);
-- Insert text with heavy duplicates to trigger RLE
INSERT INTO test_text_rle
SELECT
    CASE (i % 5)
        WHEN 0 THEN 'apple'
        WHEN 1 THEN 'banana'
        WHEN 2 THEN 'cherry'
        WHEN 3 THEN 'date'
        ELSE 'elderberry'
    END,
    i
FROM generate_series(1, 10000) i
ORDER BY 1, 2;
-- Create index with text key (should trigger text RLE path)
CREATE INDEX test_text_rle_idx ON test_text_rle USING smol(k);
-- Verify RLE is used
SELECT key_rle_pages > 0 AS text_rle_used
FROM smol_inspect('test_text_rle_idx');
 text_rle_used 
---------------
 t
(1 row)

-- Query to ensure index works
SELECT k, count(*) FROM test_text_rle WHERE k >= 'banana' GROUP BY k ORDER BY k;
     k      | count 
------------+-------
 banana     |  2000
 cherry     |  2000
 date       |  2000
 elderberry |  2000
(4 rows)

-- Test 2: UUID with duplicates (covers lines 5482-5485: case 16)
CREATE UNLOGGED TABLE test_uuid_rle(k uuid, v int);
-- Insert UUIDs with heavy duplicates
INSERT INTO test_uuid_rle
SELECT
    ('00000000-0000-0000-0000-00000000000' || (i % 10)::text)::uuid,
    i
FROM generate_series(1, 10000) i
ORDER BY 1, 2;
-- Create index with UUID key (should trigger case 16 in key extraction)
CREATE INDEX test_uuid_rle_idx ON test_uuid_rle USING smol(k);
-- Verify RLE is used
SELECT key_rle_pages > 0 AS uuid_rle_used
FROM smol_inspect('test_uuid_rle_idx');
 uuid_rle_used 
---------------
 t
(1 row)

-- Query to ensure index works
SELECT k, count(*) FROM test_uuid_rle WHERE k >= '00000000-0000-0000-0000-000000000005'::uuid GROUP BY k ORDER BY k;
                  k                   | count 
--------------------------------------+-------
 00000000-0000-0000-0000-000000000005 |  1000
 00000000-0000-0000-0000-000000000006 |  1000
 00000000-0000-0000-0000-000000000007 |  1000
 00000000-0000-0000-0000-000000000008 |  1000
 00000000-0000-0000-0000-000000000009 |  1000
(5 rows)

-- Test 3: RLE INCLUDE caching - forward scan with INCLUDE (covers line 2764 via forward scan)
CREATE UNLOGGED TABLE test_rle_inc_cache(k int4, inc1 int4, inc2 int4);
-- Heavy duplicates to trigger RLE
INSERT INTO test_rle_inc_cache
SELECT (i % 10)::int4, (i % 100)::int4, (i % 100)::int4
FROM generate_series(1, 20000) i
ORDER BY 1, 2, 3;
CREATE INDEX test_rle_inc_cache_idx ON test_rle_inc_cache USING smol(k) INCLUDE (inc1, inc2);
-- Verify include-RLE is used
SELECT inc_rle_pages > 0 AS inc_rle_used
FROM smol_inspect('test_rle_inc_cache_idx');
 inc_rle_used 
--------------
 t
(1 row)

-- Large scan to trigger RLE INCLUDE caching
SELECT k, inc1, inc2, count(*) FROM test_rle_inc_cache WHERE k <= 5 GROUP BY k, inc1, inc2 ORDER BY k, inc1, inc2 LIMIT 20;
 k | inc1 | inc2 | count 
---+------+------+-------
 0 |    0 |    0 |   200
 0 |   10 |   10 |   200
 0 |   20 |   20 |   200
 0 |   30 |   30 |   200
 0 |   40 |   40 |   200
 0 |   50 |   50 |   200
 0 |   60 |   60 |   200
 0 |   70 |   70 |   200
 0 |   80 |   80 |   200
 0 |   90 |   90 |   200
 1 |    1 |    1 |   200
 1 |   11 |   11 |   200
 1 |   21 |   21 |   200
 1 |   31 |   31 |   200
 1 |   41 |   41 |   200
 1 |   51 |   51 |   200
 1 |   61 |   61 |   200
 1 |   71 |   71 |   200
 1 |   81 |   81 |   200
 1 |   91 |   91 |   200
(20 rows)

-- Test 4: Backward scan with INCLUDE to cover line 2764 (rle_run_inc_cached in backward path)
-- Note: Backward scans are rare, but cursors can trigger them
BEGIN;
DECLARE c_back_inc SCROLL CURSOR FOR SELECT k, inc1, inc2 FROM test_rle_inc_cache WHERE k <= 3 ORDER BY k;
MOVE FORWARD ALL FROM c_back_inc;
FETCH BACKWARD 5 FROM c_back_inc;
 k | inc1 | inc2 
---+------+------
(0 rows)

CLOSE c_back_inc;
COMMIT;
-- Test 5: Debug logging for text32 in backward scans (covers lines 2788-2789, 2793-2797)
SET smol.debug_log = true;
SET enable_seqscan = false;  -- Force index usage
CREATE UNLOGGED TABLE test_text32_back(k text COLLATE "C", inc text COLLATE "C");
-- Use padded keys to get proper lexicographic ordering
INSERT INTO test_text32_back SELECT 'key' || lpad((i % 100)::text, 3, '0'), 'val' || i::text FROM generate_series(1, 1000) i ORDER BY 1, 2;
CREATE INDEX test_text32_back_idx ON test_text32_back USING smol(k) INCLUDE (inc);
ANALYZE test_text32_back;
-- Index-only backward scan to trigger debug logging
-- Must use WHERE condition that benefits from index
SELECT k, inc FROM test_text32_back WHERE k >= 'key010' AND k < 'key050' ORDER BY k DESC LIMIT 5;
   k    |  inc   
--------+--------
 key049 | val949
 key049 | val849
 key049 | val749
 key049 | val649
 key049 | val549
(5 rows)

SET enable_seqscan = true;
SET smol.debug_log = false;
-- Test 6: Prefetch depth > 1 with break (covers line 3127)
-- Create small index and set prefetch_depth to trigger break when reaching end
SET smol.prefetch_depth = 3;
CREATE UNLOGGED TABLE test_prefetch_small(k int4);
INSERT INTO test_prefetch_small SELECT i FROM generate_series(1, 100) i;
CREATE INDEX test_prefetch_small_idx ON test_prefetch_small USING smol(k);
-- Parallel scan with prefetch to cover break path
SET max_parallel_workers_per_gather = 2;
SET parallel_setup_cost = 0;
SET parallel_tuple_cost = 0;
SET min_parallel_table_scan_size = 0;
SET min_parallel_index_scan_size = 0;
SELECT COUNT(*) FROM test_prefetch_small WHERE k > 50;
 count 
-------
    50
(1 row)

RESET max_parallel_workers_per_gather;
RESET parallel_setup_cost;
RESET parallel_tuple_cost;
RESET min_parallel_table_scan_size;
RESET min_parallel_index_scan_size;
RESET smol.prefetch_depth;
-- Cleanup
DROP TABLE test_text_rle CASCADE;
DROP TABLE test_uuid_rle CASCADE;
DROP TABLE test_rle_inc_cache CASCADE;
DROP TABLE test_text32_back CASCADE;
DROP TABLE test_prefetch_small CASCADE;
