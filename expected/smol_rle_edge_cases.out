-- Comprehensive RLE edge case testing
-- Targets specific uncovered lines in RLE implementation
SET client_min_messages = warning;
CREATE EXTENSION IF NOT EXISTS smol;
-- ============================================================================
-- Test 1: int32 (4-byte) key Include-RLE (line 3169: else if key_len == 4)
-- ============================================================================
DROP TABLE IF EXISTS t_rle_int4 CASCADE;
CREATE UNLOGGED TABLE t_rle_int4 (k int4, v1 int4, v2 int4);
-- Insert repetitive int4 data to trigger RLE
INSERT INTO t_rle_int4
SELECT
    ((i / 100) % 100000)::int4 AS k,
    ((i / 100))::int4 AS v1,
    ((i / 100) * 2)::int4 AS v2
FROM generate_series(1, 10000) i;
CREATE INDEX t_rle_int4_smol ON t_rle_int4 USING smol(k) INCLUDE (v1, v2);
-- Query to access RLE data (triggers smol_leaf_keyptr_ex lines 3560-3575)
SELECT count(*), sum(v1::int8) FROM t_rle_int4 WHERE k >= 50;
 count |  sum   
-------+--------
  5001 | 372600
(1 row)

SELECT k, v1, v2 FROM t_rle_int4 WHERE k = 10 LIMIT 5;
 k  | v1 | v2 
----+----+----
 10 | 10 | 20
 10 | 10 | 20
 10 | 10 | 20
 10 | 10 | 20
 10 | 10 | 20
(5 rows)

-- ============================================================================
-- Test 2: int16 (2-byte) key Include-RLE (line 3172: else { int16 v = ... })
-- ============================================================================
DROP TABLE IF EXISTS t_rle_int2 CASCADE;
CREATE UNLOGGED TABLE t_rle_int2 (k int2, v int4);
INSERT INTO t_rle_int2
SELECT
    ((i / 50) % 30000)::int2 AS k,
    ((i / 50))::int4 AS v
FROM generate_series(1, 5000) i;
CREATE INDEX t_rle_int2_smol ON t_rle_int2 USING smol(k) INCLUDE (v);
SELECT count(*) FROM t_rle_int2 WHERE k >= 100;
 count 
-------
     1
(1 row)

-- ============================================================================
-- Test 3: Page boundary - RLE run doesn't fit (lines 3111, 3322)
-- Create data that fills page almost exactly to trigger "run doesn't fit" break
-- ============================================================================
DROP TABLE IF EXISTS t_rle_boundary CASCADE;
CREATE UNLOGGED TABLE t_rle_boundary (k int8, v1 int4, v2 int4, v3 int4, v4 int4);
-- Insert data sized to fill ~8KB pages
-- Each row: 8 (key) + 4*4 (includes) = 24 bytes
-- With RLE overhead: tag(2) + nitems(2) + nruns(2) + per-run(8+2+16) = need ~300 rows
INSERT INTO t_rle_boundary
SELECT
    ((i / 300) % 10000)::int8 AS k,
    ((i / 300))::int4 AS v1,
    ((i / 300) * 2)::int4 AS v2,
    ((i / 300) * 3)::int4 AS v3,
    ((i / 300) * 4)::int4 AS v4
FROM generate_series(1, 30000) i;
CREATE INDEX t_rle_boundary_smol ON t_rle_boundary USING smol(k) INCLUDE (v1, v2, v3, v4);
SELECT count(*) FROM t_rle_boundary WHERE k >= 5;
 count 
-------
 28501
(1 row)

-- ============================================================================
-- Test 4: Text key Include-RLE (lines 3345, 3381-3382)
-- ============================================================================
DROP TABLE IF EXISTS t_rle_text_inc CASCADE;
CREATE UNLOGGED TABLE t_rle_text_inc (k text COLLATE "C", v1 int4, v2 int4);
-- Insert repetitive text keys
INSERT INTO t_rle_text_inc
SELECT
    'textkey' || lpad(((i / 100) % 500)::text, 4, '0') AS k,
    ((i / 100))::int4 AS v1,
    ((i / 100) * 2)::int4 AS v2
FROM generate_series(1, 10000) i;
CREATE INDEX t_rle_text_inc_smol ON t_rle_text_inc USING smol(k) INCLUDE (v1, v2);
-- Query to access text RLE (line 3381: memcpy(p, k0, key_len))
SELECT count(*), sum(v1::int8) FROM t_rle_text_inc WHERE k >= 'textkey0050';
 count |  sum   
-------+--------
  5001 | 372600
(1 row)

SELECT k, v1 FROM t_rle_text_inc WHERE k = 'textkey0010' LIMIT 3;
      k      | v1 
-------------+----
 textkey0010 | 10
 textkey0010 | 10
 textkey0010 | 10
(3 rows)

-- ============================================================================
-- Test 5: Text RLE fall back to zero-copy (line 3345)
-- Create text data where RLE doesn't help (all unique keys)
-- ============================================================================
DROP TABLE IF EXISTS t_text_zerocopy CASCADE;
CREATE UNLOGGED TABLE t_text_zerocopy (k text COLLATE "C", v int4);
-- All unique keys - RLE won't help
INSERT INTO t_text_zerocopy
SELECT
    'unique' || lpad(i::text, 8, '0') AS k,
    i AS v
FROM generate_series(1, 5000) i;
CREATE INDEX t_text_zerocopy_smol ON t_text_zerocopy USING smol(k) INCLUDE (v);
SELECT count(*) FROM t_text_zerocopy WHERE k >= 'unique00001000';
 count 
-------
  4001
(1 row)

-- ============================================================================
-- Test 6: Multi-page text+include build (line 3422 - link previous page)
-- ============================================================================
DROP TABLE IF EXISTS t_text_multipage CASCADE;
CREATE UNLOGGED TABLE t_text_multipage (k text COLLATE "C", v1 int4, v2 int4);
-- Insert enough text data to span multiple pages (50K rows)
INSERT INTO t_text_multipage
SELECT
    'data' || lpad(i::text, 10, '0') AS k,
    i AS v1,
    i * 2 AS v2
FROM generate_series(1, 50000) i;
CREATE INDEX t_text_multipage_smol ON t_text_multipage USING smol(k) INCLUDE (v1, v2);
SELECT count(*) FROM t_text_multipage WHERE k >= 'data0000025000';
 count 
-------
 25001
(1 row)

-- ============================================================================
-- Test 7: RLE run boundaries and key access (lines 3645-3651, smol_run_index_range)
-- ============================================================================
DROP TABLE IF EXISTS t_rle_runs CASCADE;
CREATE UNLOGGED TABLE t_rle_runs (k int8, v1 int4, v2 int4);
-- Create distinct runs with varying lengths
INSERT INTO t_rle_runs
SELECT
    CASE
        WHEN i <= 1000 THEN 100  -- Run 1: 1000 rows
        WHEN i <= 1500 THEN 200  -- Run 2: 500 rows
        WHEN i <= 3500 THEN 300  -- Run 3: 2000 rows
        ELSE 400                 -- Run 4: remaining
    END::int8 AS k,
    i AS v1,
    i * 2 AS v2
FROM generate_series(1, 5000) i;
CREATE INDEX t_rle_runs_smol ON t_rle_runs USING smol(k) INCLUDE (v1, v2);
-- Query different runs to trigger run boundary detection
SELECT k, count(*) FROM t_rle_runs WHERE k = 100 GROUP BY k;  -- First run
  k  | count 
-----+-------
 100 |  1000
(1 row)

SELECT k, count(*) FROM t_rle_runs WHERE k = 200 GROUP BY k;  -- Middle run
  k  | count 
-----+-------
 200 |   500
(1 row)

SELECT k, count(*) FROM t_rle_runs WHERE k = 400 GROUP BY k;  -- Last run
  k  | count 
-----+-------
 400 |  1500
(1 row)

SELECT k, v1, v2 FROM t_rle_runs WHERE k = 300 LIMIT 100;     -- Access within run
  k  |  v1  |  v2  
-----+------+------
 300 | 1501 | 3002
 300 | 1502 | 3004
 300 | 1503 | 3006
 300 | 1504 | 3008
 300 | 1505 | 3010
 300 | 1506 | 3012
 300 | 1507 | 3014
 300 | 1508 | 3016
 300 | 1509 | 3018
 300 | 1510 | 3020
 300 | 1511 | 3022
 300 | 1512 | 3024
 300 | 1513 | 3026
 300 | 1514 | 3028
 300 | 1515 | 3030
 300 | 1516 | 3032
 300 | 1517 | 3034
 300 | 1518 | 3036
 300 | 1519 | 3038
 300 | 1520 | 3040
 300 | 1521 | 3042
 300 | 1522 | 3044
 300 | 1523 | 3046
 300 | 1524 | 3048
 300 | 1525 | 3050
 300 | 1526 | 3052
 300 | 1527 | 3054
 300 | 1528 | 3056
 300 | 1529 | 3058
 300 | 1530 | 3060
 300 | 1531 | 3062
 300 | 1532 | 3064
 300 | 1533 | 3066
 300 | 1534 | 3068
 300 | 1535 | 3070
 300 | 1536 | 3072
 300 | 1537 | 3074
 300 | 1538 | 3076
 300 | 1539 | 3078
 300 | 1540 | 3080
 300 | 1541 | 3082
 300 | 1542 | 3084
 300 | 1543 | 3086
 300 | 1544 | 3088
 300 | 1545 | 3090
 300 | 1546 | 3092
 300 | 1547 | 3094
 300 | 1548 | 3096
 300 | 1549 | 3098
 300 | 1550 | 3100
 300 | 1551 | 3102
 300 | 1552 | 3104
 300 | 1553 | 3106
 300 | 1554 | 3108
 300 | 1555 | 3110
 300 | 1556 | 3112
 300 | 1557 | 3114
 300 | 1558 | 3116
 300 | 1559 | 3118
 300 | 1560 | 3120
 300 | 1561 | 3122
 300 | 1562 | 3124
 300 | 1563 | 3126
 300 | 1564 | 3128
 300 | 1565 | 3130
 300 | 1566 | 3132
 300 | 1567 | 3134
 300 | 1568 | 3136
 300 | 1569 | 3138
 300 | 1570 | 3140
 300 | 1571 | 3142
 300 | 1572 | 3144
 300 | 1573 | 3146
 300 | 1574 | 3148
 300 | 1575 | 3150
 300 | 1576 | 3152
 300 | 1577 | 3154
 300 | 1578 | 3156
 300 | 1579 | 3158
 300 | 1580 | 3160
 300 | 1581 | 3162
 300 | 1582 | 3164
 300 | 1583 | 3166
 300 | 1584 | 3168
 300 | 1585 | 3170
 300 | 1586 | 3172
 300 | 1587 | 3174
 300 | 1588 | 3176
 300 | 1589 | 3178
 300 | 1590 | 3180
 300 | 1591 | 3182
 300 | 1592 | 3184
 300 | 1593 | 3186
 300 | 1594 | 3188
 300 | 1595 | 3190
 300 | 1596 | 3192
 300 | 1597 | 3194
 300 | 1598 | 3196
 300 | 1599 | 3198
 300 | 1600 | 3200
(100 rows)

-- ============================================================================
-- Test 8: Key-only RLE without includes (0x8001 format) (lines 3717-3721)
-- This requires RLE compression on keys but NO include columns
-- ============================================================================
DROP TABLE IF EXISTS t_key_rle_only CASCADE;
CREATE UNLOGGED TABLE t_key_rle_only (k int8);
-- Insert highly repetitive keys (no includes)
INSERT INTO t_key_rle_only
SELECT ((i / 1000) % 100)::int8 FROM generate_series(1, 100000) i;
-- Create index WITHOUT include columns to trigger key-only RLE (0x8001)
CREATE INDEX t_key_rle_only_smol ON t_key_rle_only USING smol(k);
-- Query to access key-only RLE
SELECT k, count(*) FROM t_key_rle_only WHERE k >= 10 GROUP BY k ORDER BY k LIMIT 10;
 k  | count 
----+-------
 10 |  1000
 11 |  1000
 12 |  1000
 13 |  1000
 14 |  1000
 15 |  1000
 16 |  1000
 17 |  1000
 18 |  1000
 19 |  1000
(10 rows)

-- ============================================================================
-- Test 9: RLE key pointer navigation (lines 3560-3575)
-- Access individual keys within RLE runs via scanning
-- ============================================================================
DROP TABLE IF EXISTS t_rle_keyptr CASCADE;
CREATE UNLOGGED TABLE t_rle_keyptr (k int8, v int4);
-- Create RLE data with specific run patterns
INSERT INTO t_rle_keyptr VALUES
    -- Run 1: key=1000, 500 times
    (SELECT 1000, generate_series FROM generate_series(1, 500)),
    -- Run 2: key=2000, 300 times
    (SELECT 2000, generate_series FROM generate_series(501, 800)),
    -- Run 3: key=3000, 700 times
    (SELECT 3000, generate_series FROM generate_series(801, 1500));
ERROR:  syntax error at or near "SELECT"
LINE 3:     (SELECT 1000, generate_series FROM generate_series(1, 50...
             ^
CREATE INDEX t_rle_keyptr_smol ON t_rle_keyptr USING smol(k) INCLUDE (v);
-- Scan to trigger key pointer access in different runs
SELECT k, v FROM t_rle_keyptr WHERE k = 1000 AND v >= 250 AND v < 260;  -- Middle of run 1
 k | v 
---+---
(0 rows)

SELECT k, v FROM t_rle_keyptr WHERE k = 2000 AND v >= 700 AND v < 710;  -- Middle of run 2
 k | v 
---+---
(0 rows)

SELECT k, v FROM t_rle_keyptr WHERE k = 3000 AND v >= 1400;              -- End of run 3
 k | v 
---+---
(0 rows)

-- Cleanup
DROP TABLE t_rle_int4 CASCADE;
DROP TABLE t_rle_int2 CASCADE;
DROP TABLE t_rle_boundary CASCADE;
DROP TABLE t_rle_text_inc CASCADE;
DROP TABLE t_text_zerocopy CASCADE;
DROP TABLE t_text_multipage CASCADE;
DROP TABLE t_rle_runs CASCADE;
DROP TABLE t_key_rle_only CASCADE;
DROP TABLE t_rle_keyptr CASCADE;
