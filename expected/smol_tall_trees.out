-- Test tree navigation for tall trees (height > 2)
-- Targets lines 4042-4050 (smol_rightmost_leaf), 4067-4086 (smol_prev_leaf)
-- Also targets 3472-3473 (rightmost child), 3787-3789 (internal node realloc)
SET client_min_messages = warning;
CREATE EXTENSION IF NOT EXISTS smol;
-- ============================================================================
-- Test 1: Very tall tree requiring smol_rightmost_leaf navigation
-- Need enough data to build height>2 tree (typically 5-10M+ rows)
-- Lines 4042-4050: Navigate down tree to find rightmost leaf
-- Lines 3787-3789: Internal node array reallocation during multi-level build
-- ============================================================================
DROP TABLE IF EXISTS t_very_tall CASCADE;
CREATE UNLOGGED TABLE t_very_tall (k int4, i1 int4, i2 int4, i3 int4, i4 int4, i5 int4, i6 int4, i7 int4, i8 int4, i9 int4, i10 int4, i11 int4, i12 int4, i13 int4, i14 int4, i15 int4, i16 int4);
-- Insert rows with 16 INCLUDE columns to reduce tuples per leaf
-- With 16 int4 INCLUDE columns (64 bytes), each tuple is ~68 bytes
-- Page is 8KB, so ~120 tuples per leaf (vs 2000 for key-only)
-- Need many leaves to get height >= 3:
--   Height 2: ~120 tuples/leaf * ~100 leaves = ~12K rows
--   Height 3: ~120 tuples/leaf * ~10K leaves = ~1.2M rows
-- Use 2M rows to ensure height >= 3 and test smol_rightmost_in_subtree loop
INSERT INTO t_very_tall
SELECT i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i
FROM generate_series(1, 2000000) i;
CREATE INDEX t_very_tall_smol ON t_very_tall USING smol(k) INCLUDE (i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16);
-- Backward scan triggers smol_prev_leaf navigation (lines 4067-4086)
-- This should navigate the tall tree structure
-- Use cursor with FETCH BACKWARD to trigger BackwardScanDirection across multiple pages
SET enable_seqscan = off;
SET enable_indexscan = off;
SET enable_bitmapscan = off;
SET enable_indexonlyscan = on;
SET max_parallel_workers_per_gather = 0;  -- Disable parallel scan to trigger smol_prev_leaf
-- Use smol_test_backward_scan to directly test backward scan which calls smol_gettuple
-- with BackwardScanDirection. This will scan backwards from the rightmost leaf, crossing
-- leaf boundaries and triggering smol_prev_leaf
-- First try without bound (scans all backwards from end)
SELECT smol_test_backward_scan('t_very_tall_smol'::regclass);
 smol_test_backward_scan 
-------------------------
                      10
(1 row)

-- Then try with bound
SELECT smol_test_backward_scan('t_very_tall_smol'::regclass, 40000);
 smol_test_backward_scan 
-------------------------
                      10
(1 row)

-- Query rightmost values (triggers rightmost leaf navigation lines 4042-4050)
SELECT k FROM t_very_tall WHERE k >= 49990 ORDER BY k LIMIT 10;
   k   
-------
 49990
 49991
 49992
 49993
 49994
 49995
 49996
 49997
 49998
 49999
(10 rows)

-- Additional queries to ensure tree navigation is exercised
SELECT count(*) FROM t_very_tall WHERE k >= 25000;
  count  
---------
 1975001
(1 row)

SELECT count(*) FROM t_very_tall WHERE k <= 25000;
 count 
-------
 25000
(1 row)

-- ============================================================================
-- Test 2: 1-byte byval key type (lines 3495)
-- ============================================================================
DROP TABLE IF EXISTS t_char_key CASCADE;
CREATE UNLOGGED TABLE t_char_key (k "char");
INSERT INTO t_char_key
SELECT (i % 127)::"char" FROM generate_series(1, 10000) i;
CREATE INDEX t_char_key_smol ON t_char_key USING smol(k);
SELECT k FROM t_char_key WHERE k >= '0'::"char" ORDER BY k LIMIT 10;
 k 
---
 0
 0
 0
 0
 0
 0
 0
 0
 0
 0
(10 rows)

SELECT count(*) FROM t_char_key WHERE k >= 'A'::"char";
 count 
-------
  4866
(1 row)

-- ============================================================================
-- Test 3: Very large Include-RLE to trigger NOTICE (line 3341)
-- Need >10K rows in single RLE run
-- ============================================================================
DROP TABLE IF EXISTS t_large_inc_rle CASCADE;
CREATE UNLOGGED TABLE t_large_inc_rle (k int8, v1 int4, v2 int4);
-- Create data with same key repeated 15K times to get large RLE run
INSERT INTO t_large_inc_rle
SELECT
    1::int8,              -- All same key
    (i / 100)::int4,      -- Repetitive includes (groups of 100)
    (i / 100)::int4
FROM generate_series(1, 15000) i;
-- This should trigger the NOTICE at line 3341 for >10K row RLE
SET client_min_messages = notice;
CREATE INDEX t_large_inc_rle_smol ON t_large_inc_rle USING smol(k) INCLUDE (v1, v2);
SET client_min_messages = warning;
SELECT count(*) FROM t_large_inc_rle WHERE k = 1;
 count 
-------
 15000
(1 row)

-- Cleanup
DROP TABLE t_very_tall CASCADE;
DROP TABLE t_char_key CASCADE;
DROP TABLE t_large_inc_rle CASCADE;
