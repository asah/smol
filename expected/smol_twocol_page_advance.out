-- Test two-column index page advancement with bounds
-- Covers lines 3677-3691: two-column page loading with binary search for bounds
CREATE EXTENSION IF NOT EXISTS smol;
NOTICE:  extension "smol" already exists, skipping
-- Enable profiling to cover prof_pages++ at line 2946
SET smol.profile = on;
-- Create a two-column index that spans multiple pages
DROP TABLE IF EXISTS t_twocol_advance CASCADE;
NOTICE:  table "t_twocol_advance" does not exist, skipping
CREATE UNLOGGED TABLE t_twocol_advance (k1 int4, k2 int4, data text);
-- Insert MORE data to ensure we span MANY pages and force page advancement
-- Use k1 values that will spread across pages
INSERT INTO t_twocol_advance
SELECT i / 1000, i, 'data' || i
FROM generate_series(1, 50000) i;
CREATE INDEX idx_twocol_advance ON t_twocol_advance USING smol(k1, k2);
-- Verify multi-page index (should have many pages now)
SELECT total_pages > 10 AS has_many_pages FROM smol_inspect('idx_twocol_advance');
 has_many_pages 
----------------
 t
(1 row)

SET enable_seqscan = off;
SET enable_bitmapscan = off;
-- Use index-only scans (SMOL's native mode)
SET enable_indexonlyscan = on;
-- Query with lower bound that forces page advancement across MANY pages
-- With k1 values from 0-49, a query for k1 >= 25 should span multiple pages
-- This will trigger the two-column page loading logic (lines 3677-3691) on each new page
SELECT count(*) FROM t_twocol_advance WHERE k1 >= 25;
 count 
-------
 25001
(1 row)

-- Query with different bound to ensure binary search on new pages
SELECT count(*) FROM t_twocol_advance WHERE k1 >= 40;
 count 
-------
 10001
(1 row)

-- Query that scans from start, forcing advancement through all pages
SELECT count(*) FROM t_twocol_advance WHERE k1 >= 0;
 count 
-------
 50000
(1 row)

-- Cleanup
DROP TABLE t_twocol_advance CASCADE;
